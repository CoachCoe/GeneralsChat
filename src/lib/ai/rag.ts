import { Chroma } from '@langchain/community/vectorstores/chroma';
import { OllamaEmbeddings } from '@langchain/ollama/embeddings';
import { prisma } from '@/lib/db';
import { PolicyChunk } from '@/types';

export class RAGSystem {
  private vectorStore: Chroma | null = null;
  private embeddings: OllamaEmbeddings;

  constructor() {
    this.embeddings = new OllamaEmbeddings({
      model: 'nomic-embed-text', // Good for embeddings
      baseUrl: process.env.OLLAMA_URL || 'http://localhost:11434',
    });
  }

  async initialize() {
    try {
      this.vectorStore = new Chroma(this.embeddings, {
        collectionName: 'policy_documents',
        url: 'http://localhost:8000', // ChromaDB default port
      });
    } catch (error) {
      console.error('Failed to initialize vector store:', error);
      // Fallback to in-memory storage for development
      this.vectorStore = null;
    }
  }

  async addPolicyDocument(policyId: string, content: string) {
    // Split content into chunks
    const chunks = this.splitIntoChunks(content);
    
    // Store chunks in database
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      const embedding = await this.embeddings.embedQuery(chunk);
      
      await prisma.policyChunk.create({
        data: {
          policyId,
          content: chunk,
          chunkIndex: i,
          embedding: JSON.stringify(embedding),
        },
      });
    }

    // Add to vector store if available
    if (this.vectorStore) {
      await this.vectorStore.addDocuments(
        chunks.map((chunk, index) => ({
          pageContent: chunk,
          metadata: { policyId, chunkIndex: index },
        }))
      );
    }
  }

  async searchRelevantPolicies(query: string, limit: number = 5): Promise<PolicyChunk[]> {
    if (!this.vectorStore) {
      // Fallback to database search
      return this.fallbackSearch(query, limit);
    }

    try {
      const results = await this.vectorStore.similaritySearch(query, limit);
      return results.map((doc, index) => ({
        id: `chunk_${index}`,
        policyId: doc.metadata.policyId,
        content: doc.pageContent,
        chunkIndex: doc.metadata.chunkIndex,
        createdAt: new Date(),
      }));
    } catch (error) {
      console.error('Vector search failed, falling back to database:', error);
      return this.fallbackSearch(query, limit);
    }
  }

  private async fallbackSearch(query: string, limit: number): Promise<PolicyChunk[]> {
    // Simple text search fallback
    const chunks = await prisma.policyChunk.findMany({
      where: {
        content: {
          contains: query,
          mode: 'insensitive',
        },
      },
      take: limit,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return chunks.map(chunk => ({
      ...chunk,
      embedding: chunk.embedding ? JSON.parse(chunk.embedding) : undefined,
    }));
  }

  private splitIntoChunks(content: string, chunkSize: number = 1000): string[] {
    const words = content.split(' ');
    const chunks: string[] = [];
    
    for (let i = 0; i < words.length; i += chunkSize) {
      const chunk = words.slice(i, i + chunkSize).join(' ');
      if (chunk.trim()) {
        chunks.push(chunk.trim());
      }
    }
    
    return chunks;
  }

  async generateResponseWithCitations(
    query: string, 
    context: any
  ): Promise<{ response: string; citations: string[] }> {
    // Search for relevant policies
    const relevantChunks = await this.searchRelevantPolicies(query, 5);
    
    // Build context from relevant chunks
    const policyContext = relevantChunks
      .map(chunk => `Policy Section: ${chunk.content}`)
      .join('\n\n');

    // Generate response using AI with policy context
    const fullContext = {
      ...context,
      relevantPolicies: policyContext,
      citations: relevantChunks.map(chunk => chunk.policyId),
    };

    // This would integrate with the AI router
    const response = `Based on the relevant policies:\n\n${policyContext}\n\n[Response would be generated by AI here]`;
    
    return {
      response,
      citations: relevantChunks.map(chunk => chunk.policyId),
    };
  }
}

export const ragSystem = new RAGSystem();
